// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/comcast/cf-zdd-plugin/commands"
)

type FakeScaleoverCommand struct {
	DoScaleoverStub        func() error
	doScaleoverMutex       sync.RWMutex
	doScaleoverArgsForCall []struct{}
	doScaleoverReturns     struct {
		result1 error
	}
	doScaleoverReturnsOnCall map[int]struct {
		result1 error
	}
	GetAppStatusStub        func(string) (*commands.AppStatus, error)
	getAppStatusMutex       sync.RWMutex
	getAppStatusArgsForCall []struct {
		arg1 string
	}
	getAppStatusReturns struct {
		result1 *commands.AppStatus
		result2 error
	}
	getAppStatusReturnsOnCall map[int]struct {
		result1 *commands.AppStatus
		result2 error
	}
	ErrorIfNoSharedRouteStub        func() error
	errorIfNoSharedRouteMutex       sync.RWMutex
	errorIfNoSharedRouteArgsForCall []struct{}
	errorIfNoSharedRouteReturns     struct {
		result1 error
	}
	errorIfNoSharedRouteReturnsOnCall map[int]struct {
		result1 error
	}
	ParseTimeStub        func(string) (time.Duration, error)
	parseTimeMutex       sync.RWMutex
	parseTimeArgsForCall []struct {
		arg1 string
	}
	parseTimeReturns struct {
		result1 time.Duration
		result2 error
	}
	parseTimeReturnsOnCall map[int]struct {
		result1 time.Duration
		result2 error
	}
	UsageStub        func(*commands.CfZddCmd) error
	usageMutex       sync.RWMutex
	usageArgsForCall []struct {
		arg1 *commands.CfZddCmd
	}
	usageReturns struct {
		result1 error
	}
	usageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeScaleoverCommand) DoScaleover() error {
	fake.doScaleoverMutex.Lock()
	ret, specificReturn := fake.doScaleoverReturnsOnCall[len(fake.doScaleoverArgsForCall)]
	fake.doScaleoverArgsForCall = append(fake.doScaleoverArgsForCall, struct{}{})
	fake.recordInvocation("DoScaleover", []interface{}{})
	fake.doScaleoverMutex.Unlock()
	if fake.DoScaleoverStub != nil {
		return fake.DoScaleoverStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.doScaleoverReturns.result1
}

func (fake *FakeScaleoverCommand) DoScaleoverCallCount() int {
	fake.doScaleoverMutex.RLock()
	defer fake.doScaleoverMutex.RUnlock()
	return len(fake.doScaleoverArgsForCall)
}

func (fake *FakeScaleoverCommand) DoScaleoverReturns(result1 error) {
	fake.DoScaleoverStub = nil
	fake.doScaleoverReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeScaleoverCommand) DoScaleoverReturnsOnCall(i int, result1 error) {
	fake.DoScaleoverStub = nil
	if fake.doScaleoverReturnsOnCall == nil {
		fake.doScaleoverReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.doScaleoverReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeScaleoverCommand) GetAppStatus(arg1 string) (*commands.AppStatus, error) {
	fake.getAppStatusMutex.Lock()
	ret, specificReturn := fake.getAppStatusReturnsOnCall[len(fake.getAppStatusArgsForCall)]
	fake.getAppStatusArgsForCall = append(fake.getAppStatusArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetAppStatus", []interface{}{arg1})
	fake.getAppStatusMutex.Unlock()
	if fake.GetAppStatusStub != nil {
		return fake.GetAppStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAppStatusReturns.result1, fake.getAppStatusReturns.result2
}

func (fake *FakeScaleoverCommand) GetAppStatusCallCount() int {
	fake.getAppStatusMutex.RLock()
	defer fake.getAppStatusMutex.RUnlock()
	return len(fake.getAppStatusArgsForCall)
}

func (fake *FakeScaleoverCommand) GetAppStatusArgsForCall(i int) string {
	fake.getAppStatusMutex.RLock()
	defer fake.getAppStatusMutex.RUnlock()
	return fake.getAppStatusArgsForCall[i].arg1
}

func (fake *FakeScaleoverCommand) GetAppStatusReturns(result1 *commands.AppStatus, result2 error) {
	fake.GetAppStatusStub = nil
	fake.getAppStatusReturns = struct {
		result1 *commands.AppStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeScaleoverCommand) GetAppStatusReturnsOnCall(i int, result1 *commands.AppStatus, result2 error) {
	fake.GetAppStatusStub = nil
	if fake.getAppStatusReturnsOnCall == nil {
		fake.getAppStatusReturnsOnCall = make(map[int]struct {
			result1 *commands.AppStatus
			result2 error
		})
	}
	fake.getAppStatusReturnsOnCall[i] = struct {
		result1 *commands.AppStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeScaleoverCommand) ErrorIfNoSharedRoute() error {
	fake.errorIfNoSharedRouteMutex.Lock()
	ret, specificReturn := fake.errorIfNoSharedRouteReturnsOnCall[len(fake.errorIfNoSharedRouteArgsForCall)]
	fake.errorIfNoSharedRouteArgsForCall = append(fake.errorIfNoSharedRouteArgsForCall, struct{}{})
	fake.recordInvocation("ErrorIfNoSharedRoute", []interface{}{})
	fake.errorIfNoSharedRouteMutex.Unlock()
	if fake.ErrorIfNoSharedRouteStub != nil {
		return fake.ErrorIfNoSharedRouteStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.errorIfNoSharedRouteReturns.result1
}

func (fake *FakeScaleoverCommand) ErrorIfNoSharedRouteCallCount() int {
	fake.errorIfNoSharedRouteMutex.RLock()
	defer fake.errorIfNoSharedRouteMutex.RUnlock()
	return len(fake.errorIfNoSharedRouteArgsForCall)
}

func (fake *FakeScaleoverCommand) ErrorIfNoSharedRouteReturns(result1 error) {
	fake.ErrorIfNoSharedRouteStub = nil
	fake.errorIfNoSharedRouteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeScaleoverCommand) ErrorIfNoSharedRouteReturnsOnCall(i int, result1 error) {
	fake.ErrorIfNoSharedRouteStub = nil
	if fake.errorIfNoSharedRouteReturnsOnCall == nil {
		fake.errorIfNoSharedRouteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.errorIfNoSharedRouteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeScaleoverCommand) ParseTime(arg1 string) (time.Duration, error) {
	fake.parseTimeMutex.Lock()
	ret, specificReturn := fake.parseTimeReturnsOnCall[len(fake.parseTimeArgsForCall)]
	fake.parseTimeArgsForCall = append(fake.parseTimeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ParseTime", []interface{}{arg1})
	fake.parseTimeMutex.Unlock()
	if fake.ParseTimeStub != nil {
		return fake.ParseTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.parseTimeReturns.result1, fake.parseTimeReturns.result2
}

func (fake *FakeScaleoverCommand) ParseTimeCallCount() int {
	fake.parseTimeMutex.RLock()
	defer fake.parseTimeMutex.RUnlock()
	return len(fake.parseTimeArgsForCall)
}

func (fake *FakeScaleoverCommand) ParseTimeArgsForCall(i int) string {
	fake.parseTimeMutex.RLock()
	defer fake.parseTimeMutex.RUnlock()
	return fake.parseTimeArgsForCall[i].arg1
}

func (fake *FakeScaleoverCommand) ParseTimeReturns(result1 time.Duration, result2 error) {
	fake.ParseTimeStub = nil
	fake.parseTimeReturns = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeScaleoverCommand) ParseTimeReturnsOnCall(i int, result1 time.Duration, result2 error) {
	fake.ParseTimeStub = nil
	if fake.parseTimeReturnsOnCall == nil {
		fake.parseTimeReturnsOnCall = make(map[int]struct {
			result1 time.Duration
			result2 error
		})
	}
	fake.parseTimeReturnsOnCall[i] = struct {
		result1 time.Duration
		result2 error
	}{result1, result2}
}

func (fake *FakeScaleoverCommand) Usage(arg1 *commands.CfZddCmd) error {
	fake.usageMutex.Lock()
	ret, specificReturn := fake.usageReturnsOnCall[len(fake.usageArgsForCall)]
	fake.usageArgsForCall = append(fake.usageArgsForCall, struct {
		arg1 *commands.CfZddCmd
	}{arg1})
	fake.recordInvocation("Usage", []interface{}{arg1})
	fake.usageMutex.Unlock()
	if fake.UsageStub != nil {
		return fake.UsageStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.usageReturns.result1
}

func (fake *FakeScaleoverCommand) UsageCallCount() int {
	fake.usageMutex.RLock()
	defer fake.usageMutex.RUnlock()
	return len(fake.usageArgsForCall)
}

func (fake *FakeScaleoverCommand) UsageArgsForCall(i int) *commands.CfZddCmd {
	fake.usageMutex.RLock()
	defer fake.usageMutex.RUnlock()
	return fake.usageArgsForCall[i].arg1
}

func (fake *FakeScaleoverCommand) UsageReturns(result1 error) {
	fake.UsageStub = nil
	fake.usageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeScaleoverCommand) UsageReturnsOnCall(i int, result1 error) {
	fake.UsageStub = nil
	if fake.usageReturnsOnCall == nil {
		fake.usageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.usageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeScaleoverCommand) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.doScaleoverMutex.RLock()
	defer fake.doScaleoverMutex.RUnlock()
	fake.getAppStatusMutex.RLock()
	defer fake.getAppStatusMutex.RUnlock()
	fake.errorIfNoSharedRouteMutex.RLock()
	defer fake.errorIfNoSharedRouteMutex.RUnlock()
	fake.parseTimeMutex.RLock()
	defer fake.parseTimeMutex.RUnlock()
	fake.usageMutex.RLock()
	defer fake.usageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeScaleoverCommand) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ commands.ScaleoverCommand = new(FakeScaleoverCommand)
